package cuid2

import (
	"fmt"
	"strings"
	"sync"
	"testing"
)

func create(t *testing.T) string {
	id := CreateId()
	if id == "" {
		t.Fatalf("Cuid not generated")
	}
	if len(id) != 24 {
		t.Errorf("Not a default 24 len. Got %d", len(id))
	}
	return id
}

func charOfString(input string, index int) string {
	return string(input[index])
}

func TestGeneratesCuid2(t *testing.T) {
	create(t)
}

func TestFirstCharFromAtoZ(t *testing.T) {
	atoz := "abcdefghijklmnopqrstuvwxyz"
	const timesRunTest = 100
	var firstChars [timesRunTest]string
	for i := range timesRunTest {
		id := create(t)
		firstChar := charOfString(id, 0)
		if !strings.Contains(atoz, firstChar) {
			t.Errorf("First char is not from a to z. Found %q\n", firstChar)
		}
		firstChars[i] = firstChar
	}
}

func TestIsCuidFalse(t *testing.T) {
	tests := []string{
		"", "1", "1", "asdf98923jhf90283jh02983hjf02983fh", "afasd as dfas ", "1asdfasdf", "   ",
		CreateId() + CreateId() + CreateId(),
	}
	for _, tt := range tests {
		t.Run(tt, func(t *testing.T) {
			isCuid := IsCuid(tt)
			if isCuid {
				t.Errorf("The input %s should not be a cuid, but it says so.", tt)
			}
		})
	}
}

func TestIsCuidWithValidIds(t *testing.T) {
	// These ids are generated by original library
	tests := []string{
		"tra51en4jnteg5yfch4ww56u",
		"hwfvvcgfp6unxxzcbwbewil8",
		"bu37v7q6sgrgzhagarwz0lpt",
		"vkdfwossmrykise0fpd4bq8x",
		"i7ls2o9hx6rlcjc9ha9tjyu7",
		"l6l6wbqcsiwxx7jvaev1m8ra",
	}
	for _, tt := range tests {
		t.Run(tt, func(t *testing.T) {
			isCuid := IsCuid(tt)
			if !isCuid {
				t.Errorf("The input %s should be a cuid, but it says it is not.", tt)
			}
		})
	}
}

func FuzzTestRandom(f *testing.F) {
	noOfIdsToGenerate := 1000
	for range noOfIdsToGenerate {
		f.Add(CreateId())
	}

	f.Fuzz(func(t *testing.T, id string) {
		if !IsCuid(id) {
			t.Errorf("Either id or isCuid is wrong for: %s", id)
		}
	})
}

func TestConfigurability(t *testing.T) {
	random := func() float64 { return 0 }
	counter := func() int64 { return 0 }
	length := 3
	fingerprint := "abc"
	fn := Init(random, counter, length, fingerprint)
	id := fn()
	if id == "" {
		t.Errorf("Custom function didn't return proper id")
	}
	if len(id) != 3 {
		t.Errorf("Id is not of len 3. Got %d", len(id))
	}
}

func TestLengthWithFullCustomization(t *testing.T) {
	minLen := 2
	maxLen := 32
	for tt := minLen; tt <= maxLen; tt++ {
		t.Run(fmt.Sprintf("with length %d", tt), func(t *testing.T) {
			createId := Init(DefaultRandom, DefaultCounter, tt, DefaultFingerprint)
			id := createId()
			fmt.Printf("Created id %q\n", id)
			if len(id) != tt {
				t.Errorf("Expected id of len %d. Got %d\n", tt, len(id))
			}
		})
	}
}

func TestLengthOnlyCustomization(t *testing.T) {
	minLen := 2
	maxLen := 32
	for tt := minLen; tt <= maxLen; tt++ {
		t.Run(fmt.Sprintf("with length %d", tt), func(t *testing.T) {
			id := CreateIdOf(tt)
			fmt.Printf("Created id %q\n", id)
			if len(id) != tt {
				t.Errorf("Expected id of len %d. Got %d\n", tt, len(id))
			}
		})
	}
}

func assertPanic(t *testing.T) {
	if r := recover(); r == nil {
		t.Errorf("Expected Panic 'len should be between 2 and 32'\n")
	}
}

func TestInvalidLength(t *testing.T) {
	tests := []int{1, 33, 0, -1}
	for _, tt := range tests {
		t.Run(fmt.Sprintf("with length %d", tt), func(t *testing.T) {
			defer assertPanic(t)
			_ = CreateIdOf(tt)
		})
	}
}

func TestCounterThreadSafe(t *testing.T) {
	var n int64 = 1_00_00_000
	pool := 10
	counter := DefaultCounter
	initialCount := counter()
	wg := &sync.WaitGroup{}
	for range pool {
		wg.Add(1)
		go func() {
			defer wg.Done()
			countTimes := n / int64(pool)
			for range countTimes {
				counter()
			}
		}()
	}
	wg.Wait()
	finalCount := counter()
	expectedCount := n + 1 // because we are counting after the loop as well.
	if finalCount-initialCount != expectedCount {
		t.Errorf("Counter should be increamented by %d times but got %d. For initial value %d and final value %d",
			expectedCount, finalCount-initialCount, initialCount, finalCount)
	}
}

func TestCounterWithInitialValue(t *testing.T) {
	start := int64(10)
	counter := CreateCounter(start)
	for i := range 100 {
		c := counter()
		want := start + int64(i)
		if c != want {
			t.Errorf("Counter is not properly incrementing. Got %d, wanted %d", c, want)
		}
	}
}
